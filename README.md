# 100 Days of DSA in C++

Welcome to my 100 Days DSA Challenge!

## ğŸ—“ï¸ Day 0 - Getting Started
- Repository created
- First file committed
- Will start solving problems from tomorrow

Stay tuned for daily updates!

##ğŸ—“ï¸ **Day 1** â€“ Sum of Array 

Solved the â€œSum of Arrayâ€ problem
Practiced basic loop traversal
Added the solution file in day1/solution.cpp
Will continue with the next problem tomorrow.â€


##ğŸ—“ï¸ **Day 2** â€“ Count Digits of a Number

Solved the â€œCount Digits of a Numberâ€ problem
Practiced basic while loop, integer division, and edge-case handling
Added the solution file in day2/solution.cpp
Moving ahead with more number-based problems tomorrow!


##ğŸ—“ï¸ **Day 3**â€“ Reverse Digits of a Number

Solved the â€œReverse Digits of a Numberâ€ problem
Practiced modulus and integer manipulation
Improved understanding of number-based logic building
Added the solution file in day3/solution.cpp
Moving ahead with more number-based problems tomorrow!!
Step by step, staying consistent on this 100-day journey! ğŸ’ªğŸ”¥


## ğŸ—“ï¸ **Day 4** â€“ Sum of Digits of a Number

Solved the â€œSum of Digitsâ€ problem.
Practiced digit extraction using modulo (%).
Strengthened loop logic and number manipulation.
Added the solution file in day4/solution.cpp.
ğŸ’¡ Little progress is still progress â€” moving ahead with more number-based problems tomorrow! ğŸš€

##ğŸ—“ï¸ **Day 5** â€“ Check if a Number is Palindrome

Solved the â€œPalindrome Numberâ€ problem.
Practiced reversing a number using modulo (%) and division.
Strengthened understanding of number manipulation and conditional checks.
Added the solution file in day5/solution.cpp.
Moving ahead with more number-based problems tomorrow inshaAllah.


**ğŸ—“ï¸ Day 6** â€“ Count Factors of a Number

Solved the â€œCount Factors of a Numberâ€ problem.
Implemented both the basic method and an optimized approach using square root logic.
Learned how factor pairs work and why traversing only up to âˆšn makes the solution faster.
Added the updated solution file in day6/solution.cpp.
Little progress every day adds up! ğŸš€
Moving ahead with more number-based problems tomorrow inshaAllah.


**ğŸ—“ï¸ Day 7** Prime Number Checker (C++)

This program checks whether a given number is **prime** or not.
A **prime number** is a natural number greater than 1 that has no positive divisors other than **1** and itself.
## âœ… Approach
To determine if a number `n` is prime:
1. If `n < 2`, it is **not** prime.
2. Check divisibility from `2` to `sqrt(n)`:
   - If any number divides `n` completely, then `n` is **not prime**.
   - We only check till `sqrt(n)` because divisor pairs repeat after that.
3. If no divisor is found, the number is **prime**.
## ğŸ§  Why loop till âˆšn?
Divisors of a number come in pairs  
`(a Ã— b = n)`.  
After `âˆšn`, these pairs start repeating.  
So checking up to square root is both correct and efficient.
## â±ï¸ Time Complexity
- **O(âˆšn)** â€” efficient for large values of `n`.
## ğŸ§® Space Complexity
- **O(1)** â€” constant space.
- Added the updated solution file in day7/solution.cpp.
- Moving ahead with more number-based problems tomorrow inshaAllah.ğŸš€


#**ğŸ—“ï¸ Day 8** GCD Using Euclid's Algorithm

This repository contains an efficient implementation of the **Greatest Common Divisor (GCD)** using the **Euclidean Algorithm**.
## ğŸ“Œ What is GCD?
The **Greatest Common Divisor** of two numbers is the largest number that divides both of them without leaving a remainder.
Example:  
`gcd(24, 36) = 12`
---
## ğŸš€ Algorithm Used: Euclid's Algorithm
Euclidâ€™s Algorithm is based on the principle:
Added the updated solution file in day8/solution.cpp.
- Moving ahead with more number-based problems tomorrow inshaAllah.ğŸš€



**ğŸ—“ï¸ Day 9**  Armstrong Number Checker

Today I solved the Armstrong Number problem.
âœ… What I did
Counted the total digits in the number
Extracted each digit using % 10
Raised each digit to the power of the digit count
Calculated the sum of these powered digits
Compared it with the original number to check if itâ€™s an Armstrong number
ğŸ¯ Key Learning
How to break a number into digits
Using pow() and loops effectively
Practicing number-based logic
Strengthening C++ fundamentals
- Moving ahead with more number-based problems tomorrow inshaAllah.ğŸš€
- 

**ğŸ—“ï¸ Day 10** â€“ LCM of Two Numbers


Solved the â€œLeast Common Multiple (LCM)â€ problem
Used the GCD (Greatest Common Divisor) approach to compute LCM efficiently
Practiced the concept: LCM(a, b) = (a Ã— b) / GCD(a, b)
Implemented the logic using the Euclidean Algorithm
Added the solution file in day10/solution.cpp
Step by step, staying consistent with number-based problems! ğŸ’ªğŸ”¥
- Moving ahead with more number-based problems tomorrow inshaAllah.ğŸš€

- 

## ğŸ—“ï¸ Day 11 â€“ Sum of Odd and Even Numbers


**Problem:** Given an integer `n`, return an array containing the sum of odd numbers and even numbers from 1 to `n`. 
The first element is the sum of odd numbers, and the second element is the sum of even numbers.
**Approach:**  
- Loop from 1 to `n`  
- Keep two variables to store the sum of odd and even numbers  
- Add numbers to the respective sum based on whether they are odd or even  
- Return a vector with `[oddSum, evenSum]`
**Time Complexity:** O(n)  
**Space Complexity:** O(1)
**Example:**
Input: n = 5
Output: [9, 6] // odd sum = 1+3+5=9, even sum = 2+4=6.
- Moving ahead with more number-based problems tomorrow inshaAllah.
- 

**ğŸ—“ï¸ Day 12** â€“ Perfect Number Checker

Solved the â€œPerfect Numberâ€ problem âœ…
Learned how to calculate proper divisors and check sum of divisors
Optimized using square root method
Solution added to the repository: day12/solution.cpp
Stay tuned for more daily coding practice! ğŸ’»
- Moving ahead with more number-based problems tomorrow inshaAllah.


**ğŸ—“ï¸ Day 13** â€“ Print Primes in Range


Solved the â€œPrint Prime Numbers in a Rangeâ€ problem.
Practiced loops, conditionals, and prime number logic.
Added the solution file at day13/solution.cpp.
Will continue with the next number based problem tomorrow inshaAllah.



**ğŸ—“ï¸ Day 14** â€“ Nth Fibonacci Number

Solved the â€œNth Fibonacci Numberâ€ problem
Practiced iterative approach using a while loop
Handled base cases and optimized for O(1) space
Added the solution file in day14/solution.cpp
Will continue with the next number based problem tomorrow inshaAllah.


## ğŸ—“ï¸ Day 15 â€“ Corner Digit Sum


Solved the â€œCorner Digit Sumâ€ problem by extracting the first and last digit of a number and returning their sum.  
Handled single-digit cases separately to avoid double counting.  
Added the solution file in day15/solution.cpp.
Will continue with the next number based problem tomorrow inshaAllah.



**ğŸ—“ï¸ Day 16**â€“ Strong Number Check

Solved the Strong Number problem
Practiced digit extraction and factorial calculation
Implemented a clean and efficient solution in C++
Added the solution file under day16/solution.cpp
Continuing the streak! ğŸš€ğŸ”¥
Will continue with the next number based problem tomorrow inshaAllah.


**ğŸ—“ï¸ Day 17** â€“ Spy Number

Today I solved the Spy Number problem in C++.
Used basic digit operations like sum and product to check the condition.
No new conceptsâ€”just applying what I learned in earlier days.
Good practice for number-based logic and loop handling.
Will continue with the next number based problem tomorrow inshaAllah.


**ğŸ—“ï¸ Day 18** â€” Trailing Zeroes in Factorial

Solved the classic trailing zeroes in n! problem using an efficient mathematical approach.
Used the idea of counting factors of 5 instead of calculating the full factorial.
A simple but powerful trick that improves logic and number-theory understanding. ğŸš€
Will continue with the next number based problem tomorrow inshaAllah.


**ğŸ—“ï¸ Day 19** â€” Binary to Decimal Conversion


Solved the Binary to Decimal conversion problem using bit manipulation.
Processed the binary number directly as a string to avoid overflow issues.
Used powers of 2 with bit shifting for an efficient and clean solution.
Great practice for understanding number systems and bit logic. ğŸš€
Will continue with the next number based problem tomorrow inshaAllah.


**ğŸ—“ï¸## Day 20** â€“ Decimal to Binary Conversion


Learned how to convert a decimal number into binary using repeated division by 2.  
Focused on understanding remainders and quotient logic instead of using built-in functions.  
This helped strengthen my basics of number systems and binary representation.
Will continue with the next number based problem tomorrow inshaAllah.


**ğŸ—“ï¸## Day 21** â€“ Happy Number

Solved the Happy Number problem and strengthened my understanding of digit manipulation and loops.  
Focused on clarity and logic rather than shortcuts.  
Alhamdulillah for the progress so far â€” **InshaAllah, moving to Arrays from tomorrow**.âœ… 


**ğŸ—“ï¸## Day 22** â€“ Linear Search (Arrays)

Alhamdulillah, started learning Arrays today and implemented Linear Search.  
As usual, beginning from the basics and focusing on array traversal and index-based access.  
A simple yet important step in building strong DSA fundamentals. ğŸš€
Will continue with the next array based problem tomorrow inshaAllah.


**## ğŸ—“ï¸Day 23** â€“ Count Even and Odd Elements (Arrays)

Alhamdulillah, practiced array traversal by counting even and odd elements.  
Focused on using simple conditions and loops to strengthen array basics.  
Continuing to build confidence step by step in my DSA journey. ğŸš€
Will continue with the next array based problem tomorrow inshaAllah.


**## ğŸ—“ï¸Day 24** â€“ Greatest Element in Array

Solved the problem of finding the greatest element in an array.
Used a single traversal approach with O(n) time complexity.
Practiced basic array traversal and comparison logic.
Will continue with the next array based problem tomorrow inshaAllah.




**## ğŸ—“ï¸Day 25**â€“ Min & Max of an Array

Solved a basic array problem to find the minimum and maximum elements using a single traversal.  
The solution is efficient with **O(n)** time complexity and **O(1)** space complexity.
Continuing to build confidence step by step in my DSA journey. ğŸš€
Will continue with the next array based problem tomorrow inshaAllah.


**## Day ğŸ—“ï¸26** â€“ Second Largest Element in Array

Solved the problem of finding the second largest element in an array.
Handled edge cases like duplicate values and missing second largest.
Used an efficient O(n) time and O(1) space approach.
Will continue with the next array based problem tomorrow inshaAllah.


**## ğŸ—“ï¸Day 27** â€“ Check if Array is Sorted

Solved a problem to check whether an array is sorted in ascending order.
Used a simple iterative approach for efficient comparison.
Focused on clean logic and edge case handling.
Time complexity is O(n) with constant space usage.
Will continue with the next array based problem tomorrow inshaAllah.


**## ğŸ—“ï¸Day 28** â€“ Find the Missing Number in Array

Solved the problem of finding the missing number using a mathematical approach.
Focused on applying basic concepts efficiently without extra space.
Achieved O(n) time and O(1) space complexity.
Will continue with the next array based problem tomorrow inshaAllah.

















